---
title: "Demographic Tables: Status by Visit"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Demographic Tables: Status by Visit}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

<!-- I know this is just a sketch/start to getting the tables set. I am just adding notes so we remember in the future when we get to the other edits/making everything 'nice'. 

This will ultimately be a pdf like what you see for how-to's in other R packages so we need to design the .Rmd to have markdown text and explanations also. Needs to be a full walk through. once we are ready to fully dive in, I found this guide on making vignettes for packages: https://r-pkgs.org/vignettes.html#vignette-advice -->

<!-- typically, these package installs/loads are part of the narative of the vignette/help .pdf for the package so we may want to re-order -->
```{r setup}
#install.packages('gtsummary')
library(gtsummary)
theme_gtsummary_compact()

#need to load the package also or it wont work
library(kellertools)
```

<!-- need a setup chunk to set your preference for the .Rmd - below is one I copied from a previous paper .Rmd, but we can edit -->
```{r setup2, include=FALSE}
knitr::opts_chunk$set(tidy = TRUE, tidy.opts = list(comment = FALSE), echo=TRUE, warning=FALSE, message=FALSE, comment = NA)

#also need .Rmd related packages loaded/installed
library(knitr)
library(kableExtra)
```

<!-- need to split chunks. Each chunk should have a single purpose so that you can control what is displayed in the pdf of the vignette.  -->
<!-- pretty sure you can't have spaces in your cunck labels when you convert to pdf -->

```{r load data}

#this path is specific to your laptop - we should try to create some fake/simulated data that we can rely on for examples
data_path = '/Users/baf44/OneDrive - The Pennsylvania State University/b-childfoodlab_Shared/Active_Studies/RO1_Brain_Mechanisms_IRB_5357/Participant_Data/untouchedRaw/Qualtrics_Raw/'

#will probably want to do individually for each table so get the data needed for each part separately - may need to change some of these to the user-interface wrappers once they are done
data_v1 <- util_fbs_merge_v1(child_file_pattern = 'Child_V1', parent_file_pattern = 'Parent_V1', data_path = data_path)
data_v2 <- util_fbs_merge_v2(child_file_pattern = 'Child_V2', parent_file_pattern = 'Parent_V2', parentV4_file_pattern = 'Parent_V4', data_path = data_path)
data_v3 <- util_fbs_merge_v3(child_file_pattern = 'Child_V3', parent_file_pattern = 'Parent_V3', data_path = data_path, model_DD = FALSE)
data_v4 <- util_fbs_merge_v4(child_file_pattern = 'Child_V4', parent_file_pattern = 'Parent_V4', data_path = data_path)
data_v5 <- util_fbs_merge_v5(child_file_pattern = 'Child_V5', parent_file_pattern = 'Parent_V5', data_path = data_path)
data_v6 <- util_fbs_merge_v6(child_file_pattern = 'Child_V6', parent_file_pattern = 'Parent_V6', data_path = data_path)
data_v7 <- util_fbs_merge_v7(child_file_pattern = 'Child_V7', parent_file_pattern = 'Parent_V7', data_path = data_path)
```

```{r V1 table}
# select variable - do for each table separately with a narative in markdown outside the chunck

# also, changed to base R indexing - the tidyverse is updated very frequently so relying on their pipes for long-standing examples will lead to the examples breaking down the line. Base R does not change indexing rules.
v1_subset <- data_v1[['data']][c('sex', 'risk_cat', 'age_yr','bmi_screenout','man_recode_risk','sex')]

v1_subset$elligible <- ifelse((v1_subset$bmi_screenout == 0 & (v1_subset$man_recode_risk == "Low Risk" | v1_subset$man_recode_risk == "High Risk")), "Yes", "No")

Table1_vars <- v1_subset[c('sex', 'risk_cat', 'age_yr','bmi_screenout','man_recode_risk')]
Table2_vars <- v1_subset[c('bmi_screenout', 'man_recode_risk','elligible')]

# Make overall eligibility variable
Table1_vars$elligible <- ifelse((Table1_vars$bmi_screenout == 1 | (Table1_vars$man_recode_risk == "Neither")), "No", "Yes")

# convert 'haven_labelled' datatypes - your loop didn't change/update the 'Table1_vars', only the df in the dfList so that tables were not able to be created. This is where it is important that it is run fully independently/with cleared environment to ensure it works. By making your loop a function, you can apply it directly to your tables and return the changes. As we move forward, it may be a good idea to make these types of functions part of the package since they aren't super common in datasets typically needed with R.

convertHaven <- function(df){
  for (v in 1:ncol(df)) {
    var_name <- names(df)[v]
    class <- class(df[[var_name]])
    if (grepl("haven_labelled", class[1])  ) {
      df[[var_name]] <- labelled::unlabelled(df[[var_name]])
    }
  }
  
  return(df)
}

Table1_vars <- convertHaven(Table1_vars)
Table2_vars <- convertHaven(Table2_vars)

# make Table 1
Table1 <- 
  tbl_summary(
    Table1_vars,
    # split table by group
    by = risk_cat,
    statistic = list(all_continuous() ~ "{mean} ({sd})",
                     all_categorical() ~ "{n} ({p}%)"),
    label = list(age_yr ~ "Age (years)",
                 sex ~ "Sex")
  ) %>%
  # update the column header
  modify_header(label = "**Variable**") %>%
  bold_labels() 

Table1


Table2 <- 
  tbl_summary(
    Table2_vars,
    # split table by group
    by = elligible,
    statistic = list(all_continuous() ~ "{mean} ({sd})",
                     all_categorical() ~ "{n} ({p}%)"),
    label = list(bmi_screenout ~ "child BMI screenout",
                 man_recode_risk ~ "risk status")
  ) %>%
  # update the column header
  modify_header(label = "**Elligible after V1**") %>%
  bold_labels() 

Table2
```
 
<!-- below is the code needed to display the table nicely in pdf format, though it should work for htlm also. tables cannot just simply be called in a chunk -- need to have instructions for formatting output -->
``` {r Table1_disp, restults = 'asis'}
as_kable_extra(Table1, caption = 'Demographic Characteristics by Risk Status', format = "latex", booktabs = TRUE, longtable = FALSE) %>%
  kableExtra::kable_styling(latex_options = "hold_position",  full_width = FALSE)
```

```{r Table2}
# make Table 2
## 
Table2 <- 
  tbl_summary(
    Table2_vars,
    by = bmi_screenout, # split table by group
    label = bmi_screenout ~ "Child BMI screenout"
  ) %>%
  modify_header(label = "**Variable**") %>% # update the column header
  bold_labels() 
```

<!-- the display of the table needs to be in it's own chunk and the results will have to be set to 'asis' -->

```{r Table2_disp}
as_kable_extra(Table2, caption = 'Child BMI Exclusion by Risk Status', format = "latex", booktabs = TRUE, longtable = FALSE) %>%
  kableExtra::kable_styling(latex_options = "hold_position",  full_width = FALSE)
```


```{r visit status table}
library(dplyr)

addDemo <- function(df, reference_df){
  for (row in 1:nrow(df)) {
    row_id = df$id[row]
    df$man_recode_risk[row] <- reference_df$man_recode_risk[reference_df$id == row_id]
    df$sex[row] <- reference_df$sex[reference_df$id == row_id]
    }
  
  return(df)
}

extractID <- function(data_v2){
  # get name of dataset
  list_name <- deparse(substitute(data_v2))
  
  # Extract ID
  list_name <- data_v2[["data"]][c('id')]

  
  return(df)
}

nonV1_datalist <- list(data_v2, data_v3, data_v4, data_v5, data_v6, data_v7)
nonV1_data <- lapply(nonV1_datalist, addDemo)


# Extract IDs from individual visit databases and create visit column
V1 <- data_v1[["data"]][c('id', 'man_recode_risk','sex')]
V1$visit <- "1"

V2 <- data_v2[["data"]][c('id')]
V2$visit <- "2"

V3 <- data_v3[["data"]][c('id')]
V3$visit <- "3"

V4 <- data_v4[["data"]][c('id')]
V4$visit <- "4"

V5 <- data_v5[["data"]][c('id')]
V5$visit <- "5"

V6 <- data_v6[["data"]][c('id')]
V6$visit <- "6"

V7 <- data_v7[["data"]][c('id')]
V7$visit <- "7"

# Add risk status, sex, age to V2-V7 dataframes by referencing V1
nonV1_list <- list(V2, V3, V4, V5, V6, V7)
nonV1_list <- lapply(nonV1_list, addDemo, reference_df = V1)

# Combine visit dataframes
V1_7 <- bind_rows(V1, nonV1_list)

# Convert 'haven_labelled' datatypes 
V1_7 <- convertHaven(V1_7)

# Remove ID column 
V1_7 <- subset(V1_7, select = -c(id))

# Create table
Table3 <- 
  tbl_summary(
    V1_7,
    by = visit, # split table by group
    label = list(sex ~ "Sex",
                 man_recode_risk ~ "Risk status")
  ) %>%
  modify_header(label = "**Visit**") %>% # update the column header
  bold_labels() 

Table3
```
